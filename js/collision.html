<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<script src="d3.v3.min.js"></script>
<script src="jamendo-data.js"></script>
<style>
.overlay {
  fill: none;
  pointer-events: all;
}
</style>
</head>

<body>

<div id="audio"></div>
<div id="body">


<script type="text/javascript">

var RADIUS = 20

// Number of sectors in one dimension, actual number of sectors is the power of two.
// Each sector contains a copy of all the nodes.
// This enables scrolling over the edge
var NUMBER_OF_SECTORS = 2

// This should probably be a whole number, so that when node doesn't keep oscilating after reaching its final size
var NODE_GROWTH_RATE = 1

var TRIANGLE_SIZE_FACTOR = 0.72
var TRIANGLE_COLOR = "black"
var TRIANGLE_BORDER_COLOR = "white"
var TRIANGLE_FILL_OPACITY = 0.48
var TRIANGLE_STROKE_OPACITY = 0.22

var songs = JSON.parse(songs);

var w = window,
    e = document.documentElement,
    g = document.getElementsByTagName('body')[0]

var width = w.innerWidth || e.clientWidth || g.clientWidth;
var height = w.innerHeight|| e.clientHeight|| g.clientHeight;

//################
//##### DATA #####
//################

var numOfSongs = Object.keys(songs.songs).length

// Each node has 4 bubles, each in one sector,
var nodes = d3.range(numOfSongs*NUMBER_OF_SECTORS*NUMBER_OF_SECTORS).map(function() { return {r: RADIUS}; })
	
nodes.forEach(function(d, i) { 
	// SET id
	var keys = Object.keys(songs.songs)
	var songIndex = keys[i%numOfSongs]
	d.id = songIndex.slice(1)

	var sectorIndex = Math.floor(i/numOfSongs)

	// SET X
	var tempo = songs.songs[songIndex].tempo
	var sectorX = sectorIndex % NUMBER_OF_SECTORS
	d.fociX = getFociX(tempo) + sectorX * width
	d.x = d.fociX

	// SET Y
	var key = songs.songs[songIndex].key
	var sectorY = Math.floor(sectorIndex/NUMBER_OF_SECTORS)
	d.fociY = getFociY(key) + sectorY * height
	d.y = d.fociY

	// SET R
	d.fociR = d.r
})

function getFociX(tempo) {
	if (tempo == 0) {
		tempo = Math.random()
	}
	var logOfTempo = Math.floor( Math.log(tempo) / Math.log(2));
	var tempoFloor = Math.pow(2, logOfTempo)
	var widthRatio = (tempo - tempoFloor) / tempoFloor
	return width * widthRatio
}

function getFociY(key) {
	// the keys are ordered in circle of fifths,
	// so that songs with keys that sound nicer together get positioned 
	// closer to one another 
	var positions = [11, 4, 9, 2, 7, 12, 5, 10, 3, 8, 1, 6]
	var pos = positions[key]
	var heightRatio = pos / 12	
	return height * heightRatio
}

// Add to every node the map of the distances to other nodes
nodes.forEach(function(d) { 
	d.distances = {}
	nodes.forEach(function(e) {
		d.distances[e.id] = getDistance(d, e)
	})
})

function getDistance(node1, node2) {
	var distance = getDistanceA(node1.fociX, node1.fociY, node2.fociX, node2.fociY)
	// It needs to check if any distance to the node in
	// adjacent sectors of the torus space is smaller then the
	// one inside its own sector
	// NOTE: it will also work without it for the upper left corner nodes,
	// but not for the lower right. I don't know why.
	for (i = -1; i <= 1; i++) {
		for (j = -1; j <= 1; j++) {
			var x2 = node2.fociX + width*i
			var y2 = node2.fociY + height*i
			var distanceCandidate = getDistanceA(node1.fociX, node1.fociY, x2, y2)
			if (distanceCandidate < distance) {
				distance = distanceCandidate
			}
		}
	}
	return distance
}

function getDistanceA(x1, y1, x2, y2) {
	var dx = x1 - x2 
	var dy = y1 - y2
	return Math.sqrt(Math.pow(dx,2) + Math.pow(dy,2))
}

//###############
//##### SVG #####
//###############

// From pan limit example
var PAN_LIMIT_X = width*NUMBER_OF_SECTORS
var PAN_LIMIT_Y = height*NUMBER_OF_SECTORS
var panExtent = {x: [-width*2/3,2*width*2/3], y:[height,height*2] };

// From pan limit example
var x = d3.scale.linear()
    .domain([	panExtent.x[0] > (-width / 2) 	? panExtent.x[0] : (-width / 2),
				panExtent.x[1] < (width / 2) 	? panExtent.x[1] : (width / 2)	])
    .range([0, width*3]);
	
// From pan limit example
var y = d3.scale.linear()
    .domain([	panExtent.y[0] > (-height / 2)	? panExtent.y[0] : (-height / 2),
				panExtent.y[1] < (height / 2)	? panExtent.y[1] : (height / 2)	])
    .range([height, 0]);

// From pan limit example
var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom")

// From pan limit example
var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left")

// From pan limit example
var zoom = d3.behavior.zoom()
    .x(x)
    .y(y)
    .scaleExtent([1, 8])
    .on("zoom", zoomed);

var svg = d3.select("#body").append("svg:svg")
    .attr("width", width)
    .attr("height", height)
  .append("g")
	.call(zoom)
    // EX: .call(d3.behavior.zoom().scaleExtent([1, 8]).on("zoom", zoomHandler))
  .append("g");

svg.append("rect")
    .attr("class", "overlay")
    .attr("width", width*NUMBER_OF_SECTORS)
    .attr("height", height*NUMBER_OF_SECTORS);


var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom")

var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left")

// From pan limit example
function zoomed() {
//OLD:
	//svg.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");

	//1
	svg.attr("transform", "translate(" + panLimit() + ")scale(" + d3.event.scale + ")");

	//2
  //zoom.translate(d3.event.translate);
  //zoom.scale(d3.event.scale)

	//3
  //zoom.translate(panLimit());
					
  svg.select(".x.axis").call(xAxis);
  svg.select(".y.axis").call(yAxis);
}


function panLimit() {
	/*	
	include boolean to work out the panExtent and return to zoom.translate()
	*/

	var divisor = { h: height / ((y.domain()[1]-y.domain()[0])*zoom.scale()), 
					w: width / ((x.domain()[1]-x.domain()[0])*zoom.scale()) }

	var minX = -(x.domain()[0] - x.domain()[1]) * zoom.scale() + (panExtent.x[1] - (panExtent.x[1] - width/divisor.w)),
		minY = -(((y.domain()[0] - y.domain()[1]) * zoom.scale()) + (panExtent.y[1] - (panExtent.y[1] - (height*(zoom.scale())/divisor.h))))*divisor.h,
		maxX = -(((x.domain()[0] - x.domain()[1])) + (panExtent.x[1] - panExtent.x[0])) * divisor.w * zoom.scale(),
		maxY = (((y.domain()[0] - y.domain()[1]) * zoom.scale()) + (panExtent.y[1] - panExtent.y[0])) * divisor.h*zoom.scale() 

	console.log("panExtent.x[0] "+panExtent.x[0])
	console.log("x.domain()[0] "+x.domain()[0])
	console.log("x.domain()[1] "+x.domain()[1])
	console.log("panExtent.x[1] "+panExtent.x[1])
	//console.log("-----------")
	//console.log("panExtent.y[0] "+panExtent.y[0])
	//console.log("y.domain()[0] "+y.domain()[0])
	//console.log("y.domain()[1] "+y.domain()[1])
	//console.log("panExtent.y[1] "+panExtent.y[1])
	console.log("minX "+minX)
	//console.log("minY "+minY)
	console.log("maxX "+maxX)
	//console.log("maxY "+maxY)
	console.log("width "+width)

	/*
	var	tx = x.domain()[0] < panExtent.x[0] ? 
				-width : 
				x.domain()[1] > panExtent.x[1] ? 
					-20 : 
					zoom.translate()[0]
	*/

	var tx = 0
	if (x.domain()[0] < panExtent.x[0]) {
		tx = -width  
		x.domain()[0] = 500
	} else {
		if (x.domain()[1] > panExtent.x[1]) {
			tx = -20  
		} else {
			tx = zoom.translate()[0]
		}
	}

	var ty = zoom.translate()[1]

	console.log("tx "+tx)
	console.log("ty "+ty)
	console.log("============")
/*
		ty = y.domain()[0]  < panExtent.y[0]? 
				maxY : 
				y.domain()[1] > panExtent.y[1] ? 
					minY : 
					zoom.translate()[1];
*/
/*
	var	tx = x.domain()[0] < panExtent.x[0] ? 
				maxX : 
				x.domain()[1] > panExtent.x[1] ? 
					minX : 
					zoom.translate()[0],
		ty = y.domain()[0]  < panExtent.y[0]? 
				maxY : 
				y.domain()[1] > panExtent.y[1] ? 
					minY : 
					zoom.translate()[1];
*/
	
	return [tx,ty];
}

function zoomHandler() {
	svg.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
}

//#################
//##### NODES #####
//#################

var node = svg.selectAll("g")
	.data(nodes)
  	.enter().append("g")
	.on("click", function(d) { play(d) })
	.attr('id', function(d) { return 'name' + d.id })

var clipPath = node.append("clipPath")
	.attr("id", "cut-off-bottom")

clipPath.append("circle")
    .attr("cx", function(d) { return d.r; })
    .attr("cy", function(d) { return d.r; })
    .attr("r", function(d) { return d.r; })

node.append("image")
	.attr("x", "0")
	.attr("y", "0")
	.attr("xlink:href", function(d) { return "../JamendoDataset/"+ d.id + ".jpg" })
    .attr("height", function(d) { return (d.r) * 2; })
    .attr("width", function(d) { return (d.r) * 2; })
	.attr("clip-path", "url(#cut-off-bottom)")

addPlayIcon(node)

function enlargeNode(g) {
	nodes.forEach(function(d) {
		var gId = g.attr("id").slice(4)
		if (d.id == gId) {
			d.fociR = RADIUS * 2
		}
	})
	force.start();
}

function shrinkNode(g) {
	nodes.forEach(function(d) {
		var gId = g.attr("id").slice(4)
		if (d.id == gId) {
			d.fociR = RADIUS
		}
	})
	force.start();
}

function addPlayIcon(ggg) {
	var s = TRIANGLE_SIZE_FACTOR
	var r = RADIUS

	// there are five points so that all corners are rendered nicely
	var triangle = [ 
			{ "x": r - (r*0.55 * s), "y": r - (r*0.45 * s) }, 
			{ "x": r + (r*0.75 * s), "y": r },
			{ "x": r - (r*0.55 * s), "y": r + (r*0.45 * s) },
			{ "x": r - (r*0.55 * s), "y": r - (r*0.45 * s) },
			{ "x": r + (r*0.75 * s), "y": r }
		];

	var lineFunction = d3.svg.line()
			.x(function(d) { return d.x; })
			.y(function(d) { return d.y; })
			.interpolate("linear");

	var path = ggg.append("path")
		.attr("d", lineFunction(triangle))
		.attr("stroke", TRIANGLE_BORDER_COLOR)
		.attr("stroke-opacity", "0.0")
		.attr("stroke-width", "0.7")
   		.attr("fill-opacity","0.0")
		.attr("fill", "true")
		.attr("fill", TRIANGLE_COLOR)
}

//###################
//##### ON TICK #####
//###################

var force = d3.layout.force()
    .gravity(0)
    .nodes(nodes)
    .size([width, height])
	.links([])

force.start();

force.on("tick", function(e) {
	var k = .1 * e.alpha;
    nodes.forEach(function(o) {
		o.y += (o.fociY - o.y) * k
		o.x += (o.fociX - o.x) * k
		if (o.r < o.fociR) {
			o.r = o.r + NODE_GROWTH_RATE
		} else if (o.r > o.fociR) {
			o.r = o.r - NODE_GROWTH_RATE
		}
	});

   var q = d3.geom.quadtree(nodes)
   nodes.forEach(function(o) { q.visit(collide(o)) })

   svg.selectAll("g")
  		.attr("transform", function(d) { 
			var relativeSize = d.r/RADIUS
			var x = d.x - d.r
			var y = d.y - d.r
			return "translate("+x+","+y+")scale("+relativeSize+")" 
		})
		.select("path") // transparency of play icon depends on the radius
			.attr("fill-opacity", function(d) { return ((d.r/RADIUS)-1) * TRIANGLE_FILL_OPACITY })
			.attr("stroke-opacity",function(d) { return ((d.r/RADIUS)-1) * TRIANGLE_STROKE_OPACITY }) 
});

function collide(node) {
  var r = node.r + 16,
      nx1 = node.x - r,
      nx2 = node.x + r,
      ny1 = node.y - r,
      ny2 = node.y + r;
  return function(quad, x1, y1, x2, y2) {
    if (quad.point && (quad.point !== node)) {
      var x = node.x - quad.point.x,
          y = node.y - quad.point.y,
          l = Math.sqrt(x * x + y * y),
          r = node.r + quad.point.r;
      if (l < r) {
        l = (l - r) / l * .5;
        node.x -= x *= l;
        node.y -= y *= l;
        quad.point.x += x;
        quad.point.y += y;
      }
    }
    return x1 > nx2
        || x2 < nx1
        || y1 > ny2
        || y2 < ny1;
  };
}

//#################
//##### AUDIO #####
//#################

generateAudioElements()

var AUTOPLAY = true
var alreadyPlayedTracks = []


function generateAudioElements() {
	var audioDiv = document.getElementById("audio")
	for (var id in songs.songs) {
		var id = id.slice(1)
		var audioElement = document.createElement("audio")
		audioElement.setAttribute("id", "audio"+id);
		audioElement.setAttribute("src", "../JamendoDataset/"+id+".mp3");

		// ENDED
		audioElement.addEventListener('ended', function(e) {
			var g = d3.select('#name' + this.id.slice(5))
			shrinkNode(g)
			if (AUTOPLAY) {
				alreadyPlayedTracks.push(this.id.slice(5))
				var nextSong = findClosestNode(g)
				play(nextSong)
			}
		}, false);

		// PLAY
		audioElement.addEventListener('play', function(e) {
			var g = d3.select('#name' + this.id.slice(5))
			enlargeNode(g)			
		}, false);

		// PAUSE
		audioElement.addEventListener('pause', function(e) {
			var g = d3.select('#name' + this.id.slice(5))
			shrinkNode(g)
		}, false);

		audioDiv.appendChild(audioElement)
	}
}

var playingAudio=""

function play(nodesData){
	var audioFileId = nodesData.id
	var node = d3.select( '#name' + audioFileId );	
   	var audio = document.getElementById("audio"+audioFileId);
   	if (audio.paused) {
		if (playingAudio != "") {
			playingAudio.pause();
			playingAudio.currentTime = 0;
		}
	   	audio.play();
	   	playingAudio=audio;
   	} else {
	   	audio.pause();
	   	audio.currentTime = 0;
   	}
}

function findClosestNode(nodeIn) {
	var closestNode = null
	var smallestDistance = 99999

	nodes.forEach(function(d) {
		var nodeInId = nodeIn.attr("id").slice(4)
		var distance = d.distances[nodeInId]
		var nodeIsNotTheSameOne = nodeInId != d.id
		var nodeIsClosestOneYet = distance < smallestDistance
		var songHasntBeenPlayedYet = !contains(alreadyPlayedTracks, d.id)
		if (nodeIsNotTheSameOne && nodeIsClosestOneYet && songHasntBeenPlayedYet) {
			closestNode = d
			smallestDistance = distance
		}
	})
	return closestNode
}

//################
//##### UTIL #####
//################

function contains(a, obj) {
    var i = a.length;
    while (i--) {
       if (a[i] === obj) {
           return true;
       }
    }
    return false;
}


</script>
</body></html>
