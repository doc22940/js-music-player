<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<script src="d3.v3.min.js"></script>
<script src="jquery-2.1.3.js"></script>
<script src="jamendo-data.js"></script>
<style>
.overlay {
  fill: none;
  pointer-events: all;
}
</style>
</head>
<body>
<div id="body">
<script type="text/javascript">

//////////////////////////////////////
var RADIUS = 20
var PLAYING_RADIUS_FACTOR = 2.5

// Number of sectors in one dimension, actual number of sectors is the power of two.
// Each sector contains a copy of all the nodes.
// This enables scrolling over the edge
var NUMBER_OF_SECTORS = 2

// This should probably be a whole number, so that node size doesn't keep oscilating after reaching its final size
var NODE_GROWTH_RATE = 1

var TRIANGLE_SIZE_FACTOR = 0.72
var TRIANGLE_COLOR = "white"
var BACKGROUND_COLOR = "black"
var TRIANGLE_FILL_OPACITY = 0.9 //0.64
var BACKGROUND_OPACITY = 0.22

var AUTOPLAY = true
var FADE_DURATION = 2000
var CROSSFADE_VOLUME = true
//////////////////////////////////////

var songs = JSON.parse(songs);

var w = window,
    e = document.documentElement,
    g = document.getElementsByTagName('body')[0]

var width = w.innerWidth || e.clientWidth || g.clientWidth;
var height = w.innerHeight|| e.clientHeight|| g.clientHeight;

//################
//##### DATA #####
//################

var numOfSongs = Object.keys(songs.songs).length

// Each node has 4 bubles, each in one sector,
var data = d3.range(numOfSongs*NUMBER_OF_SECTORS*NUMBER_OF_SECTORS).map(function() { return {r: RADIUS}; })
	
data.forEach(function(d, i) { 
	// SET id
	var keys = Object.keys(songs.songs)
	var songIndex = keys[i%numOfSongs]
	d.id = songIndex.slice(1)

	var sectorIndex = Math.floor(i/numOfSongs)

	// SET X
	var tempo = songs.songs[songIndex].tempo
	var sectorX = sectorIndex % NUMBER_OF_SECTORS
	d.fociX = getFociX(tempo) + sectorX * width
	d.x = d.fociX

	// SET Y
	var key = songs.songs[songIndex].key
	var sectorY = Math.floor(sectorIndex/NUMBER_OF_SECTORS)
	d.fociY = getFociY(key) + sectorY * height
	d.y = d.fociY

	// SET R
	//d.fociR = d.r
})

function getFociX(tempo) {
	if (tempo == 0) {
		tempo = Math.random()
	}
	var logOfTempo = Math.floor( Math.log(tempo) / Math.log(2));
	var tempoFloor = Math.pow(2, logOfTempo)
	var widthRatio = (tempo - tempoFloor) / tempoFloor
	return width * widthRatio
}

function getFociY(key) {
	// the keys are ordered in circle of fifths,
	// so that songs with keys that sound nicer together get positioned 
	// closer to one another 
	var positions = [11, 4, 9, 2, 7, 12, 5, 10, 3, 8, 1, 6]
	var pos = positions[key]
	var heightRatio = pos / 12	
	return height * heightRatio
}

// Add to every node the map of the distances to other nodes
data.forEach(function(d) { 
	d.distances = {}
	data.forEach(function(e) {
		d.distances[e.id] = getDistance(d, e)
	})
})

function getDistance(node1, node2) {
	var distance = getDistanceA(node1.fociX, node1.fociY, node2.fociX, node2.fociY)
	// It needs to check if any distance to the node in
	// adjacent sectors of the torus space is smaller then the
	// one inside its own sector
	// NOTE: it will also work without it for the upper left corner nodes,
	// but not for the lower right. I don't know why.
	for (i = -1; i <= 1; i++) {
		for (j = -1; j <= 1; j++) {
			var x2 = node2.fociX + width*i
			var y2 = node2.fociY + height*i
			var distanceCandidate = getDistanceA(node1.fociX, node1.fociY, x2, y2)
			if (distanceCandidate < distance) {
				distance = distanceCandidate
			}
		}
	}
	return distance
}

function getDistanceA(x1, y1, x2, y2) {
	var dx = x1 - x2 
	var dy = y1 - y2
	return Math.sqrt(Math.pow(dx,2) + Math.pow(dy,2))
}

//###############
//##### SVG #####
//###############

var svg = d3.select("#body").append("svg:svg")
    .attr("width", width)
    .attr("height", height)
  .append("g")
    .call(d3.behavior.zoom().scaleExtent([1, 8]).on("zoom", zoomHandler))
  .append("g");

svg.append("rect")
    .attr("class", "overlay")
    .attr("width", width*NUMBER_OF_SECTORS)
    .attr("height", height*NUMBER_OF_SECTORS);

//#################
//##### NODES #####
//#################

var nodes = svg.selectAll("g")
	.data(data)
  	.enter().append("g")
	.on("click", function(d) { play(d) })
	.attr('id', function(d) { return 'name' + d.id })

var clipPath = nodes.append("clipPath")
	.attr("id", "cut-off-bottom")

clipPath.append("circle")
    .attr("cx", function(d) { return d.r; })
    .attr("cy", function(d) { return d.r; })
    .attr("r", function(d) { return d.r; })

nodes.append("image")
	.attr("x", "0")
	.attr("y", "0")
	.attr("xlink:href", function(d) { return "../JamendoDataset/"+ d.id + ".jpg" })
    .attr("height", function(d) { return (d.r) * 2; })
    .attr("width", function(d) { return (d.r) * 2; })
	.attr("clip-path", "url(#cut-off-bottom)")

addPlayIcon(nodes)

function zoomHandler() {
	svg.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
}

/*
function enlargeNode(g) {
	setRadius(g, RADIUS * 2)
}

function shrinkNode(g) {
	setRadius(g, RADIUS)
}

function setRadius(g, radius) {
	var gId = g.attr("id").slice(4)
	data.forEach(function(d) {
		if (d.id == gId) {
			d.fociR = radius
		}
	})
	force.start();
}
*/

function addPlayIcon(ggg) {
	var s = TRIANGLE_SIZE_FACTOR
	var r = RADIUS

	// there are five points so that all corners are rendered nicely
	var triangle = [ 
			{ "x": r - (r*0.55 * s), "y": r - (r*0.45 * s) }, 
			{ "x": r + (r*0.75 * s), "y": r },
			{ "x": r - (r*0.55 * s), "y": r + (r*0.45 * s) },
			{ "x": r - (r*0.55 * s), "y": r - (r*0.45 * s) },
			{ "x": r + (r*0.75 * s), "y": r }
		];

	var lineFunction = d3.svg.line()
			.x(function(d) { return d.x; })
			.y(function(d) { return d.y; })
			.interpolate("linear");

	var shade = ggg.append("circle")
		.attr("cx", function(d) { return d.r; })
		.attr("cy", function(d) { return d.r; })
		.attr("r", function(d) { return d.r; })
		.attr("fill", BACKGROUND_COLOR)
   		.attr("fill-opacity","0.4")

	var path = ggg.append("path")
		.attr("d", lineFunction(triangle))
   		.attr("fill-opacity","0.0")
		.attr("fill", TRIANGLE_COLOR)
}

//###################
//##### ON TICK #####
//###################

var force = d3.layout.force()
    .gravity(0)
    .nodes(data)
    .size([width, height])
	.links([])

force.start();

force.on("tick", function(e) {
	var k = .1 * e.alpha;
  data.forEach(function(o) {
		o.y += (o.fociY - o.y) * k
		o.x += (o.fociX - o.x) * k

		// remove node growth rate
		/*
		if (o.r < o.fociR) {
			o.r = o.r + NODE_GROWTH_RATE
		} else if (o.r > o.fociR) {
			o.r = o.r - NODE_GROWTH_RATE
		}
		*/
	});

	var q = d3.geom.quadtree(data)
	data.forEach(function(o) { q.visit(collide(o)) })

	var ggg = svg.selectAll("g")
  		.attr("transform", function(d) { 
			var relativeSize = d.r/RADIUS
			var x = d.x - d.r
			var y = d.y - d.r
			return "translate("+x+","+y+")scale("+relativeSize+")" 
		})
   
  ggg.selectAll("circle")
			.attr("fill-opacity", function(d) { return ((d.r/RADIUS)-1) * BACKGROUND_OPACITY })

	ggg.select("path") // transparency of play icon depends on the radius
			.attr("fill-opacity", function(d) { return ((d.r/RADIUS)-1) * TRIANGLE_FILL_OPACITY })
});

function collide(node) {
  var r = node.r + 16,
      nx1 = node.x - r,
      nx2 = node.x + r,
      ny1 = node.y - r,
      ny2 = node.y + r;
  return function(quad, x1, y1, x2, y2) {
    if (quad.point && (quad.point !== node)) {
      var x = node.x - quad.point.x,
          y = node.y - quad.point.y,
          l = Math.sqrt(x * x + y * y),
          r = node.r + quad.point.r;
      if (l < r) {
        l = (l - r) / l * .5;
        node.x -= x *= l;
        node.y -= y *= l;
        quad.point.x += x;
        quad.point.y += y;
      }
    }
    return x1 > nx2
        || x2 < nx1
        || y1 > ny2
        || y2 < ny1;
  };
}

//#################
//##### AUDIO #####
//#################

generateAudioElements()

// already played audio elements
var played = []

// last audio element that started playing and is still playing
var playing = ""

// Id of a timeout function that was most recently created.
// Used for crossfades at the end of songs.
var timeout = ""

function generateAudioElements() {
	for (var id in songs.songs) {
		var id = id.slice(1)
	  var track = new Audio()
		var audioElement = document.createElement("source")
		track.setAttribute("id", "audio"+id);
		audioElement.setAttribute("src", "../JamendoDataset/"+id+".mp3");

		// ENDED
		track.addEventListener('ended', function(e) {
			console.log("ENDED event "+this.id)
			//shrinkNode(this, FADE_DURATION)
		}, false);

		// PLAY
		track.addEventListener('play', function(e) {
			console.log("PLAY event "+this.id)
			//enlargeNode(this, FADE_DURATION)
		}, false);

		// PAUSE
		track.addEventListener('pause', function(e) {
			console.log("PAUSE event "+this.id)
			//shrinkNode(this, FADE_DURATION)
		}, false);

		track.appendChild(audioElement)
		document.body.appendChild(track)
	}
}

function play(nodesData){
	var audioFileId = nodesData.id
	var node = d3.select( '#name' + audioFileId );	
	var audioEl = document.getElementById("audio"+audioFileId);

	console.log("play function "+audioEl.id)

	if (audioEl.paused) {
		startPlayback(audioEl)
	} else {
		stopPlayback()
	}
}

function startPlayback(audioEl) {
	stopPlayback()
	var id = audioEl.id.slice(5)
	played.push(id)
	playing = audioEl
	fadeIn(audioEl)

	// start next song at the beginning of fadeout
	// or just clear state
	var timeBeforeFadeout = Math.round( audioEl.duration * 1000 - FADE_DURATION )
	timeout = setTimeout(function(){
		var id = $(audioEl).attr('id').slice(5)
		console.log("audioEl.id "+audioEl.id)
		if (AUTOPLAY) {
			fadeOut(audioEl)
			playNextSong(id)
		} else {
			playing = ""
			timeout = ""
		}
	}, timeBeforeFadeout);
}

function playNextSong(id) {
	var g = d3.select('#name' + id)
	var nextSong = findClosestNode(g)
	play(nextSong)
}

function stopPlayback() {
	if (playing == "") {
		return
	}
	fadeOut(playing)
	playing = ""
	clearTimeout(timeout)
	timeout = ""
}

function fadeIn(audioEl) {
	if (CROSSFADE_VOLUME) {
		$(audioEl).prop('volume', 0.0)
		$(audioEl).animate({volume: 1.0}, FADE_DURATION);
	}
	audioEl.play()
	enlargeNode(audioEl, FADE_DURATION)
}

function fadeOut(audioEl) {
	console.log("fadeOut, audioEl "+audioEl.id)
	if (CROSSFADE_VOLUME) {
		$(audioEl).animate({volume: 0.0}, FADE_DURATION);
	}
	setTimeout(function() {
		audioEl.pause()
		audioEl.currentTime = 0
	}, FADE_DURATION);
	shrinkNode(audioEl, FADE_DURATION)
}

function findClosestNode(nodeIn) {
	var closestNode = null
	var smallestDistance = 99999

	data.forEach(function(d) {
		var nodeInId = nodeIn.attr("id").slice(4)
		var distance = d.distances[nodeInId]
		var nodeIsNotTheSameOne = nodeInId != d.id
		var nodeIsClosestOneYet = distance < smallestDistance
		var songHasntBeenPlayedYet = !contains(played, d.id)
		if (nodeIsNotTheSameOne && nodeIsClosestOneYet && songHasntBeenPlayedYet) {
			closestNode = d
			smallestDistance = distance
		}
	})
	return closestNode
}

function shrinkNode(audioEl, duration) {
	changeNodesRadius(audioEl, RADIUS, duration)
}

function enlargeNode(audioEl, duration) {
	changeNodesRadius(audioEl, RADIUS*PLAYING_RADIUS_FACTOR, duration)
}

function changeNodesRadius(audioEl, radius, duration) {
	var id = audioEl.id.slice(5)
	console.log("id "+id)
	console.log("radius "+radius)
	console.log("duration "+duration)
	var g = d3.select('#name' + id)
	var d = getNodesData(g)
	$(d).animate({r: radius}, duration);
	force.start();
}

//################
//##### UTIL #####
//################

function contains(a, obj) {
    var i = a.length;
    while (i--) {
       if (a[i] === obj) {
           return true;
       }
    }
    return false;
}

function getNodesData(g) {
	var gId = g.attr("id").slice(4)
	for (var i = 0; i < data.length; i++) {
		var d = data[i]
		if (d.id == gId) {
			return d
		}
	}
}

</script>
</body></html>
